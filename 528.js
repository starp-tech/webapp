(()=>{"use strict";const e=(e,...t)=>postMessage({type:e,payload:t}),t=function(){const t=function(...e){throw new Error(e.join(" "))};globalThis.window===globalThis?t("This code cannot run from the main thread.","Load it as a Worker from a separate Worker."):navigator?.storage?.getDirectory||t("This API requires navigator.storage.getDirectory.");const n=Object.create(null);n.verbose=1;const s={0:void 0,1:void 0,2:void 0},a=(e,...t)=>{n.verbose>e&&s[e]("OPFS asyncer:",...t)},i=(...e)=>a(2,...e),o=(...e)=>a(1,...e),c=(...e)=>a(0,...e),r=Object.create(null);r.reset=()=>{let e;for(e in n.opIds)(t=r[e]=Object.create(null)).count=t.time=t.wait=0;var t;let s=r.s11n=Object.create(null);s=s.serialize=Object.create(null),s.count=s.time=0,s=r.s11n.deserialize=Object.create(null),s.count=s.time=0},r.dump=()=>{let e,t=0,s=0,a=0;for(e in n.opIds){const n=r[e];t+=n.count,s+=n.time,a+=n.wait,n.avgTime=n.count&&n.time?n.time/n.count:0}};const l=Object.create(null),d=new Set,f=function(e,t){const n=new URL(e,"file://irrelevant").pathname;return t?n.split("/").filter((e=>!!e)):n},y=async function(e,t=!1){const s=f(e,!0),a=s.pop();let i=n.rootDir;for(const e of s)e&&(i=await i.getDirectoryHandle(e,{create:!!t}));return[i,a]},u=async e=>{if(e.syncHandle){i("Closing sync handle for",e.filenameAbs);const t=e.syncHandle;return delete e.syncHandle,delete e.xLock,d.delete(e.fid),t.close()}},p=async e=>{try{await u(e)}catch(t){o("closeSyncHandleNoThrow() ignoring:",t,e)}},b=async()=>{if(d.size)for(const e of d){const t=l[e];await p(t),i("Auto-unlocked",e,t.filenameAbs)}},m=async e=>{if(e.releaseImplicitLocks&&d.has(e.fid))return p(e)};class w extends Error{constructor(e,...t){super([...t,": "+e.name+":",e.message].join(" "),{cause:e}),this.name="GetSyncHandleError"}}w.convertRc=(e,t)=>e instanceof w&&("NoModificationAllowedError"===e.cause.name||"DOMException"===e.cause.name&&0===e.cause.message.indexOf("Access Handles cannot"))?n.sq3Codes.SQLITE_BUSY:t;const E=async(e,t)=>{if(!e.syncHandle){const s=performance.now();i("Acquiring sync handle for",e.filenameAbs);const a=6,c=2*n.asyncIdleWaitTime;let r=1,l=c;for(;;l=c*++r)try{e.syncHandle=await e.fileHandle.createSyncAccessHandle();break}catch(s){if(r===a)throw new w(s,"Error getting sync handle for",t+"().",a,"attempts failed.",e.filenameAbs);o("Error getting sync handle for",t+"(). Waiting",l,"ms and trying again.",e.filenameAbs,s),Atomics.wait(n.sabOPView,n.opIds.retry,0,l)}i("Got",t+"() sync handle for",e.filenameAbs,"in",performance.now()-s,"ms"),e.xLock||(d.add(e.fid),i("Acquired implicit lock for",t+"()",e.fid,e.filenameAbs))}return e.syncHandle},O=(e,t)=>{i(e+"() => notify(",t,")"),Atomics.store(n.sabOPView,n.opIds.rc,t),Atomics.notify(n.sabOPView,n.opIds.rc)},g=function(e,n){n.readOnly&&t(e+"(): File is read-only: "+n.filenameAbs)},h=Object.create(null);h.op=void 0,h.start=void 0;const x=e=>{h.start=performance.now(),h.op=e,++r[e].count},I=()=>r[h.op].time+=performance.now()-h.start,S=Object.create(null);S.op=void 0,S.start=void 0;const T=e=>{S.start=performance.now(),S.op=e},R=()=>r[S.op].wait+=performance.now()-S.start;let L=!1;const A={"opfs-async-metrics":async()=>{x("opfs-async-metrics"),r.dump(),O("opfs-async-metrics",0),I()},"opfs-async-shutdown":async()=>{L=!0,O("opfs-async-shutdown",0)},mkdir:async e=>{x("mkdir");let t=0;T("mkdir");try{await y(e+"/filepart",!0)}catch(e){n.s11n.storeException(2,e),t=n.sq3Codes.SQLITE_IOERR}finally{R()}O("mkdir",t),I()},xAccess:async e=>{x("xAccess");let t=0;T("xAccess");try{const[t,n]=await y(e);await t.getFileHandle(n)}catch(e){n.s11n.storeException(2,e),t=n.sq3Codes.SQLITE_IOERR}finally{R()}O("xAccess",t),I()},xClose:async function(e){const t="xClose";x(t),d.delete(e);const s=l[e];let a=0;if(T(t),s){if(delete l[e],await u(s),s.deleteOnClose)try{await s.dirHandle.removeEntry(s.filenamePart)}catch(e){o("Ignoring dirHandle.removeEntry() failure of",s,e)}}else n.s11n.serialize(),a=n.sq3Codes.SQLITE_NOTFOUND;R(),O(t,a),I()},xDelete:async function(...e){x("xDelete");const t=await A.xDeleteNoWait(...e);O("xDelete",t),I()},xDeleteNoWait:async function(e,t=0,s=!1){let a=0;T("xDelete");try{for(;e;){const[n,a]=await y(e,!1);if(!a)break;if(await n.removeEntry(a,{recursive:s}),4660!==t)break;s=!1,(e=f(e,!0)).pop(),e=e.join("/")}}catch(e){n.s11n.storeException(2,e),a=n.sq3Codes.SQLITE_IOERR_DELETE}return R(),a},xFileSize:async function(e){x("xFileSize");const t=l[e];let s=0;T("xFileSize");try{const e=await(await E(t,"xFileSize")).getSize();n.s11n.serialize(Number(e))}catch(e){n.s11n.storeException(1,e),s=w.convertRc(e,n.sq3Codes.SQLITE_IOERR)}await m(t),R(),O("xFileSize",s),I()},xLock:async function(e,t){x("xLock");const s=l[e];let a=0;const i=s.xLock;if(s.xLock=t,!s.syncHandle){T("xLock");try{await E(s,"xLock"),d.delete(e)}catch(e){n.s11n.storeException(1,e),a=w.convertRc(e,n.sq3Codes.SQLITE_IOERR_LOCK),s.xLock=i}R()}O("xLock",a),I()},xOpen:async function(e,t,s,a){const i="xOpen";x(i);const o=n.sq3Codes.SQLITE_OPEN_CREATE&s;T("xOpen");try{let c,r;try{[c,r]=await y(t,!!o)}catch(e){return n.s11n.storeException(1,e),O(i,n.sq3Codes.SQLITE_NOTFOUND),I(),void R()}if(n.opfsFlags.OPFS_UNLINK_BEFORE_OPEN&a)try{await c.removeEntry(r)}catch(e){}const d=await c.getFileHandle(r,{create:o});R();const f=Object.assign(Object.create(null),{fid:e,filenameAbs:t,filenamePart:r,dirHandle:c,fileHandle:d,sabView:n.sabFileBufView,readOnly:!o&&n.sq3Codes.SQLITE_OPEN_READONLY&s,deleteOnClose:!!(n.sq3Codes.SQLITE_OPEN_DELETEONCLOSE&s)});f.releaseImplicitLocks=a&n.opfsFlags.OPFS_UNLOCK_ASAP||n.opfsFlags.defaultUnlockAsap,l[e]=f,O(i,0)}catch(e){R(),c(i,e),n.s11n.storeException(1,e),O(i,n.sq3Codes.SQLITE_IOERR)}I()},xRead:async function(e,t,s){x("xRead");let a,i=0;const o=l[e];try{T("xRead"),a=(await E(o,"xRead")).read(o.sabView.subarray(0,t),{at:Number(s)}),R(),a<t&&(o.sabView.fill(0,a,t),i=n.sq3Codes.SQLITE_IOERR_SHORT_READ)}catch(e){void 0===a&&R(),c("xRead() failed",e,o),n.s11n.storeException(1,e),i=w.convertRc(e,n.sq3Codes.SQLITE_IOERR_READ)}await m(o),O("xRead",i),I()},xSync:async function(e,t){x("xSync");const s=l[e];let a=0;if(!s.readOnly&&s.syncHandle){try{T("xSync"),await s.syncHandle.flush()}catch(e){n.s11n.storeException(2,e),a=n.sq3Codes.SQLITE_IOERR_FSYNC}R()}O("xSync",a),I()},xTruncate:async function(e,t){x("xTruncate");let s=0;const a=l[e];T("xTruncate");try{g("xTruncate",a),await(await E(a,"xTruncate")).truncate(t)}catch(e){c("xTruncate():",e,a),n.s11n.storeException(2,e),s=w.convertRc(e,n.sq3Codes.SQLITE_IOERR_TRUNCATE)}await m(a),R(),O("xTruncate",s),I()},xUnlock:async function(e,t){x("xUnlock");let s=0;const a=l[e];if(n.sq3Codes.SQLITE_LOCK_NONE===t&&a.syncHandle){T("xUnlock");try{await u(a)}catch(e){n.s11n.storeException(1,e),s=n.sq3Codes.SQLITE_IOERR_UNLOCK}R()}O("xUnlock",s),I()},xWrite:async function(e,t,s){let a;x("xWrite");const i=l[e];T("xWrite");try{g("xWrite",i),a=t===(await E(i,"xWrite")).write(i.sabView.subarray(0,t),{at:Number(s)})?0:n.sq3Codes.SQLITE_IOERR_WRITE}catch(e){c("xWrite():",e,i),n.s11n.storeException(1,e),a=w.convertRc(e,n.sq3Codes.SQLITE_IOERR_WRITE)}await m(i),R(),O("xWrite",a),I()}},v=async function(){const e=Object.create(null);for(let t of Object.keys(n.opIds)){const s=A[t];if(!s)continue;const a=Object.create(null);e[n.opIds[t]]=a,a.key=t,a.f=s}for(;!L;)try{if("not-equal"!==Atomics.wait(n.sabOPView,n.opIds.whichOp,0,n.asyncIdleWaitTime)){await b();continue}const s=Atomics.load(n.sabOPView,n.opIds.whichOp);Atomics.store(n.sabOPView,n.opIds.whichOp,0);const a=e[s]??t("No waitLoop handler for whichOp #",s),i=n.s11n.deserialize(!0)||[];a.f?await a.f(...i):c("Missing callback for opId",s)}catch(e){c("in waitLoop():",e)}};navigator.storage.getDirectory().then((function(s){n.rootDir=s,globalThis.onmessage=function({data:s}){switch(s.type){case"opfs-async-init":{const a=s.args;for(const e in a)n[e]=a[e];n.verbose=a.verbose??1,n.sabOPView=new Int32Array(n.sabOP),n.sabFileBufView=new Uint8Array(n.sabIO,0,n.fileBufferSize),n.sabS11nView=new Uint8Array(n.sabIO,n.sabS11nOffset,n.sabS11nSize),Object.keys(A).forEach((e=>{Number.isFinite(n.opIds[e])||t("Maintenance required: missing state.opIds[",e,"]")})),(()=>{if(n.s11n)return n.s11n;const e=new TextDecoder,s=new TextEncoder("utf-8"),a=new Uint8Array(n.sabIO,n.sabS11nOffset,n.sabS11nSize),i=new DataView(n.sabIO,n.sabS11nOffset,n.sabS11nSize);n.s11n=Object.create(null);const o=Object.create(null);o.number={id:1,size:8,getter:"getFloat64",setter:"setFloat64"},o.bigint={id:2,size:8,getter:"getBigInt64",setter:"setBigInt64"},o.boolean={id:3,size:4,getter:"getInt32",setter:"setInt32"},o.string={id:4};const c=e=>{switch(e){case o.number.id:return o.number;case o.bigint.id:return o.bigint;case o.boolean.id:return o.boolean;case o.string.id:return o.string;default:t("Invalid type ID:",e)}};n.s11n.deserialize=function(t=!1){++r.s11n.deserialize.count;const s=performance.now(),o=a[0],l=o?[]:null;if(o){const t=[];let s,r,d,f=1;for(s=0;s<o;++s,++f)t.push(c(a[f]));for(s=0;s<o;++s){const o=t[s];o.getter?(d=i[o.getter](f,n.littleEndian),f+=o.size):(r=i.getInt32(f,n.littleEndian),f+=4,d=e.decode(a.slice(f,f+r)),f+=r),l.push(d)}}return t&&(a[0]=0),r.s11n.deserialize.time+=performance.now()-s,l},n.s11n.serialize=function(...e){const c=performance.now();if(++r.s11n.serialize.count,e.length){const c=[];let r=0,d=1;for(a[0]=255&e.length;r<e.length;++r,++d)c.push((l=e[r],o[typeof l]||t("Maintenance required: this value type cannot be serialized.",l))),a[d]=c[r].id;for(r=0;r<e.length;++r){const t=c[r];if(t.setter)i[t.setter](d,e[r],n.littleEndian),d+=t.size;else{const t=s.encode(e[r]);i.setInt32(d,t.byteLength,n.littleEndian),d+=4,a.set(t,d),d+=t.byteLength}}}else a[0]=0;var l;r.s11n.serialize.time+=performance.now()-c},n.s11n.storeException=n.asyncS11nExceptions?(e,t)=>{e<=n.asyncS11nExceptions&&n.s11n.serialize([t.name,": ",t.message].join(""))}:()=>{},n.s11n})(),r.reset(),i("init state",n),e("opfs-async-inited"),v();break}case"opfs-async-restart":L&&(o("Restarting after opfs-async-shutdown. Might or might not work."),L=!1,v());break;case"opfs-async-metrics":r.dump()}},e("opfs-async-loaded")})).catch((e=>c("error initializing OPFS asyncer:",e)))};globalThis.SharedArrayBuffer?globalThis.Atomics?globalThis.FileSystemHandle&&globalThis.FileSystemDirectoryHandle&&globalThis.FileSystemFileHandle&&globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle&&navigator?.storage?.getDirectory?t():e("opfs-unavailable","Missing required OPFS APIs."):e("opfs-unavailable","Missing Atomics API.","The server must emit the COOP/COEP response headers to enable that."):e("opfs-unavailable","Missing SharedArrayBuffer API.","The server must emit the COOP/COEP response headers to enable that.")})();